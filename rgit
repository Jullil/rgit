#!/bin/bash

SETCOLOR_SUCCESS="echo -en \\033[1;32m"
SETCOLOR_FAILURE="echo -en \\033[1;31m"
SETCOLOR_NORMAL="echo -en \\033[0;39m"

SRED=$(tput setf 4)
SGREEN=$(tput setf 2)
SRESET=$(tput sgr0)
STOEND=$(tput hpa $(tput cols))$(tput cub 6)


SCRIPT_PATH=$(cd $(dirname $0) && pwd)
CUR_PATH=`pwd`;

function print_help() {
	case $1 in
		"start-task" | "pull")
			echo "Usage: grit start-task|st <branch_name> [-d <repository_name>]"
			echo "Params:"
			echo "  -d             	   Call the command for certain repositories"
		;;
		*)
			echo "Usage: grit <command> [<args>] [-d <repository_name>]"
			echo "Commands:"
			echo "  pull|p             Fetch from and merge with another repository or a local branch (see git command)"
			echo "  branch|b           List, create, or delete branches (see git command)"
			echo "  checkout|ch        Checkout a branch or paths to the working tree (see git command)"
			echo "  fetch|f            Download objects and refs from another repository (see git command)"
			echo "  commit|c           Record changes to the repository (see git command)"
			echo "  push|ps            Update remote refs along with associated objects (see git command)"
			echo "  start-task|st      Switch to master or develop branch. Fetch changes. Create and checkout to new branch."
			echo "  finish-task|ft     Switch to branch. Commit and push changes to remote branch. Switch to master or develop branch."
			echo "Params:"
			echo "  -d             	   Call the command for certain repositories"
		;;
	esac
}

fetch_modules() {
    echo "Get all modules"
    _file="${CUR_PATH}/repository_list"

    _num=0
    while read _line
    do
		_module_name=`echo $_line | head -n1 | awk '{print $1;}'`
		#echo $_module_name
		if [ -z $selected_module_name ]
		then
			module_list[$_num]="${_line[@]}"
			_num=$(($_num+1))
		else
			if [ $selected_module_name = $_module_name ]
			then
				module_list[$_num]=${_line[*]}
				_num=$(($_num+1))
			fi
		fi
    done < $_file
}

source $SCRIPT_PATH/commands/pull
source $SCRIPT_PATH/commands/branch
source $SCRIPT_PATH/commands/checkout
source $SCRIPT_PATH/commands/fetch
source $SCRIPT_PATH/commands/commit
source $SCRIPT_PATH/commands/push

source $SCRIPT_PATH/commands/start_task
source $SCRIPT_PATH/commands/finish_task

exec_command() {
	_command_name=$1
	shift
	_command_args=($*)
	
	_module_name=$1
	_module_path=$2
	
	_dir="${CUR_PATH}/${_module_path}"

	_command_args[1]=$_dir
	
	if [ -d $_dir ] 
	then
		case $_command_name in
			"p" | "pull")
				echo "Pull changes of module ${_module_name}"
				pull ${_command_args[*]}
			;;
			"ps" | "push")
				echo "Push changes for module \"${_module_name}\""
				push ${_command_args[*]}
			;;
			"f" | "fetch")
				echo "Fetch branches for module \"${_module_name}\""
				fetch ${_command_args[*]}
			;;
			"c" | "commit")
				echo "Commit changes for module \"${_module_name}\""
				commit ${_command_args[*]}
			;;
			"b" | "branch")
				echo "Create new branch for module \"${_module_name}\""
				branch ${_command_args[*]}
			;;
			"ch" | "checkout")
				echo "Checkout to branch for module \"${_module_name}\""
				checkout ${_command_args[*]}
			;;
			"st" | "start-task")
				echo "Start new task for module \"${_module_name}\""
				start_task ${_command_args[*]}
			;;
			"ft" | "finish-task")
				echo "Finish task for module \"${_module_name}\""
				finish_task ${_command_args[*]}
			;;
			*)
				echo "Unknown operation \"$_command_name\""
			;;
		esac
	else
		$SETCOLOR_FAILURE
		echo "Module \"$_module_name\" not found ($_dir)"
		echo "Use \"rgit pull -d $_module_name\""
		echo "${SRED}${STOEND}[fail]"
		echo -n "${SRESET}"
	fi
}

if [ -z $1 ]
then
	$SETCOLOR_FAILURE
	echo "Command not found"
	echo -n "${SRESET}"
	print_help
else
	_operation=$1
	shift
	
	_arg_num=0
	while [ $# != "0" ]
	do 
		case $1 in
			"-d")
				echo "Module name $2"
				selected_module_name=$2
				shift
			;;
			*)
				_arguments[$_arg_num]=$1
				_arg_num=$(($_arg_num+1))
		esac  
		  
		shift
	done

	# Fetch information about modules
	fetch_modules

	for  ((_i=0; _i<${#module_list[@]}; _i++))
	do
		echo '---------------------------------------------------------'
		_module_data=(${module_list[$_i]})
		exec_command $_operation ${_module_data[*]} ${_arguments[*]}
	done
fi




